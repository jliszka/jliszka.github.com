---
layout: post
title: "Infinite lazy polynomials"
description: ""
category: 
tags: [ "automatic differentiation" ]
---
{% include JB/setup %}

> _"Never underestimate the insights encoded into the coefficients of a polynomial."_<br/>
> â€”Steven Rudich

In this post I'm going to write a toy library for manipulating infinite lazy polynomials.

### Arithmetic

### Division

### Log and exp

### Fractional powers

### Fun with polynomials

- Binomial coefficients
- difference and running sum

### Generating functions

Generating functions are awesome. The basic idea is that if you have an infinite sequence
of numbers, you first create a polynomial with those numbers as coefficients. Then you find a function whose Taylor series
expansion is that polynomial.

A simple example is the sequence {%m%}a_n = 1{%em%}, that is, the sequence of all 1s. This maps to the polynomial

{% math %}
1 + x + x^2 + x^3 + \ldots = \frac{1}{1-x}
{% endmath %}

You would say that {%m%}\frac{1}{1-x}{%em%} is the generating function for {%m%}a_n = 1{%em%}.
(Here the value of {%m%}x{%em%} and the radius of convergence of the functions are irrelevant; these formulas are to be
interpreted symbolically, not numerically.)

The sequence {%m%}a_n = n{%em%} can likewise be generated by

{% math %}
\begin{align}
x + 2x^2 + 3x^3 + 4x^4 + \ldots & = x\frac{d}{dx}(1 + x + x^2 + x^3 + \ldots) \\
&= x\frac{d}{dx}\frac{1}{1-x} \\
&= \frac{x^2}{(1-x)^2}
\end{align}
{% endmath %}

You can even find the generating the Fibonacci sequence from its recurrence relation. It turns out to be

{% math %}
\frac{x}{1 - x - x^2} = x + x^2 + 2x^3 + 3x+^4 + 5x^6 + 8x^7 + 13x^8 + \ldots + F(i)x^i + \ldots
{% endmath %}

Anyway, there are all sorts of algebraic tricks to figure out what the generating function is for a sequence, given either 
a recurrence relation or a formula for each term of the sequence.

If you're curious about it, you should head on over to [Generatingfunctionology](http://www.math.upenn.edu/~wilf/gfologyLinked2.pdf).
It's like a whole book on generating functions. The intro and first chapter give you a good sense for the power of this
technique, from counting to statistical analysis to proving certain identities.

The other day I was thinking whether any part of the practice of constructing or evaluating generating functions can
be automated. Finding the function that generates a given polynomial involves a lot of cleverness and trickery, so
it's probably not a good task for a computer.

How about going the other way, checking your work, seeing what sequence a function generates?
Actually this is pretty easy! All we need is to be able to compute the Taylor series expansion of an arbitrary function.

{% highlight scala %}
def generate(f: Dual => Dual) = f(e)
{% endhighlight %}

OK let's try it:

    scala> val fibs = x / (1 - x - x**2)
    fibs: Dual = { 0.0, 1.0, 1.0, 2.0, 3.0, 5.0, 8.0, 13.0, 21.0, 34.0, ... }

    scala> fibs(50).toLong
    res0: Long = 12586269025

### Derivatives

### Blass




