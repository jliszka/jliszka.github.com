---
layout: post
title: "Generating functions"
description: ""
category: 
tags: []
---
{% include JB/setup %}

> _"Never underestimate the amount of information that can be encoded in the coefficients of a polynomial."_
> â€”Dana C. Scott

Generating functions are one witness to the truth of this statement. The basic idea is that if you have an infinite sequence
of numbers, you can create a polynomial with those numbers as coefficients. Then you find a function whose Taylor series
expansion is that polynomial.

A simple example is the sequence {%m%}a_n = 1{%em%}, that is, the sequence of all 1s. Ths maps to the polynomial

{% math %}
1 + x + x^2 + x^3 + \ldots = \frac{1}{1-x}
{% endmath %}

You would say that {%m%}\frac{1}{1-x}{%em%} is the generating function for {%m%}a_n = 1{%em%}.
(Here the value of {%m%}x{%em%} and the radius of convergence of the functions are irrelevant; these formulas are to be
interpreted symbolically, not numerically.)

The sequence {%m%}a_n = n{%em%} can likewise be generated by

{% math %}
\begin{align}
x + 2x^2 + 3x^3 + 4x^4 + \ldots & = x\frac{d}{dx}(1 + x + x^2 + x^3 + \ldots) \\
&= x\frac{d}{dx}\frac{1}{1-x} \\
&= \frac{x^2}{(1-x)^2}
\end{align}
{% endmath %}

You can even find the generating the Fibonacci sequence from its recurrence relation. It turns out that

{% math %}
\frac{x}{1 - x - x^2} = x + x^2 + 2x^3 + 3x+^4 + 5x^6 + 8x^7 + 13x^8 + \ldots + F(i)x^i + \ldots
{% endmath %}

There are all sorts of algebraic tricks to figure out what the generating function is for a sequence given a
recurrence relation or a formula for each term of the sequence.

If you're curious about it, you should head on over to [Generatingfunctionology](). It's like a whole book on
generating functions. But the intro and first chapter give you a good sense for the power of this technique, from
counting to etc etc.

I was thinking the other day whether any part of the practice of constructing or evaluating generating functions can
be automated. Finding the function that generates a given polynomial involves a lot of cleverness and trickery, so
it's probably not a good task for a computer.

How about going the other way, checking your work, seeing what sequence
a function generates? That might be doable. It would be great if I could do

    scala> val fibs = generate(x => x / (1 - x - x^2))
    fibs: Stream[Int] = Stream(0, 1, 1, 2, 3, 5, 8, 13, ...) 

{% highlight scala %}

def generate(f: Dual => Dual, n: Int) = {
  f(new D(n))
}

implicit def intToDual(i: Int): Dual = new I(1000) * i

generate(x => x / (i - x - x.pow(2)), 6)

{% endhighlight %}

