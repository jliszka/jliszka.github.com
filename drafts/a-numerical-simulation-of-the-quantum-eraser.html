
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>The Quantum Eraser</title>
    <meta name="description" content="">
    <meta name="author" content="Jason Liszka">

    <!-- Enable responsive viewport -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="/assets/themes/twitter/bootstrap/css/bootstrap.2.2.2.min.css" rel="stylesheet">
    <link href="/assets/themes/twitter/css/style.css?body=1&amp;v=2" rel="stylesheet" type="text/css" media="all">
    <link href="/assets/themes/twitter/css/pygment.css" rel="stylesheet" type="text/css" media="all">

    <!-- Le fav and touch icons -->
  <!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->

    <!-- atom & rss feed -->
    <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM Feed">
    <link href="/rss.xml" type="application/rss+xml" rel="alternate" title="Sitewide RSS Feed">
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  </head>

  <body>
    <div class="navbar">
      <div class="navbar-inner">
        <div class="container-narrow">
          <div class="row-fluid">
            <div class="span9 offset1">
              <a class="brand" href="/">A Gentleman and a Scala</a>
              <ul class="nav">
                
                
                


  
    
      
      	
      	<li><a href="/archive.html">Archive</a></li>
      	
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/tags.html">Tags</a></li>
      	
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  



              </ul>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container-narrow">

      <div class="content">
        
<div class="row-fluid">
  <div class="span9 offset1 post-content post-spacer"></div>
</div>
<div class="row-fluid post-full">
  <div class="span9 offset1 post-content">
    <div class="page-header">
      <h1>The Quantum Eraser </h1>
    </div>
    <div class="date">
      <span>28 July 2014</span>
    </div>
    <div class="content">
      
<p>The <a href="https://en.wikipedia.org/wiki/Quantum_eraser_experiment">Quantum Eraser</a> is a variation on the classic
<a href="https://en.wikipedia.org/wiki/Double_slit_experiment">double-slit experiment</a>.
If you ever have any doubt about the weirdness of quantum mechanics (“oh, there’s probably some classical explanation
for all of this”), this experiment is designed to remove it.</p>

<p>The experiment involves two entangled polarized photons. The first goes straight to a detector, and the second passes
through a barrier with two slits before reaching a detector.</p>

<p>The experiment proceeds in three stages. I’m going to simulate each stage using my
<a href="https://github.com/jliszka/quantum-probability-monad">toy quantum computing library</a> (see
earlier post <a href="/2013/09/09/the-3-things-you-should-understand-about-quantum-computing.html">here</a>), and we’ll see what happens!</p>

<!-- more -->

<h3 id="preliminaries">Preliminaries</h3>

<p>Let’s model the quantum state. Here’s how we’ll represent the polarization of a photon:</p>

<div class="highlight"><pre><code class="scala"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Polarization</span><span class="o">(</span><span class="n">label</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Basis</span><span class="o">(</span><span class="n">label</span><span class="o">)</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">Horizontal</span> <span class="k">extends</span> <span class="nc">Polarization</span><span class="o">(</span><span class="s">&quot;H&quot;</span><span class="o">)</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">Vertical</span> <span class="k">extends</span> <span class="nc">Polarization</span><span class="o">(</span><span class="s">&quot;V&quot;</span><span class="o">)</span></code></pre></div>

<p><code>Horizontal</code> and <code>Vertical</code> are our basis vectors. We’ll also define pure states of these basis vectors:</p>

<div class="highlight"><pre><code class="scala"><span class="k">val</span> <span class="n">h</span><span class="k">:</span> <span class="kt">Q</span><span class="o">[</span><span class="kt">Polarization</span><span class="o">]</span> <span class="k">=</span> <span class="n">pure</span><span class="o">(</span><span class="nc">Horizontal</span><span class="o">)</span>
<span class="k">val</span> <span class="n">v</span><span class="k">:</span> <span class="kt">Q</span><span class="o">[</span><span class="kt">Polarization</span><span class="o">]</span> <span class="k">=</span> <span class="n">pure</span><span class="o">(</span><span class="nc">Vertical</span><span class="o">)</span></code></pre></div>

<p>We also need to represent which slit the photon went through (this is only intermediate information and
won’t show up in the final state we will construct).</p>

<div class="highlight"><pre><code class="scala"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Slit</span><span class="o">(</span><span class="n">label</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Basis</span><span class="o">(</span><span class="n">label</span><span class="o">)</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">A</span> <span class="k">extends</span> <span class="nc">Slit</span><span class="o">(</span><span class="s">&quot;A&quot;</span><span class="o">)</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">B</span> <span class="k">extends</span> <span class="nc">Slit</span><span class="o">(</span><span class="s">&quot;B&quot;</span><span class="o">)</span>

<span class="k">val</span> <span class="n">a</span><span class="k">:</span> <span class="kt">Q</span><span class="o">[</span><span class="kt">Slit</span><span class="o">]</span> <span class="k">=</span> <span class="n">pure</span><span class="o">(</span><span class="n">A</span><span class="o">)</span>
<span class="k">val</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Q</span><span class="o">[</span><span class="kt">Slit</span><span class="o">]</span> <span class="k">=</span> <span class="n">pure</span><span class="o">(</span><span class="n">B</span><span class="o">)</span></code></pre></div>

<p>And finally, we’ll need to represent the position of the detector for the second photon. Instead of a single detector
changing positions throughout the course of the experiment, we’ll model this as an array of detectors.</p>

<div class="highlight"><pre><code class="scala"><span class="k">case</span> <span class="k">class</span> <span class="nc">Detector</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Basis</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="n">toString</span><span class="o">)</span></code></pre></div>

<script type="math/tex">
\newcommand{\ket}[1]{\lvert #1 \rangle}
\newcommand{\bra}[1]{\langle #1 \rvert}
\newcommand{\braket}[2]{\langle #1 \rvert #2 \rangle}
</script>

<h3 id="stage-1-the-double-slit-experiment">Stage 1: The double-slit experiment</h3>

<p>In the first stage, we reproduce the interference effect from the double-slit experiment. We’ll do this by
building up the quantum state of the system and then performing measurements of the number of photons that reach
each of the detectors.</p>

<p>We’ll build up the quantum state of the system by starting with a photon emitted from a laser and applying various
transformations corresponding to the events that take place during the course of the experiment.</p>

<p>Here’s the initial state of the photon as it gets emitted from the laser:</p>

<div class="highlight"><pre><code class="scala"><span class="k">val</span> <span class="n">rhalf</span><span class="k">:</span> <span class="kt">Complex</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="o">(</span><span class="mf">0.5</span><span class="o">)</span>
<span class="k">val</span> <span class="n">emit</span><span class="k">:</span> <span class="kt">Q</span><span class="o">[</span><span class="kt">Polarization</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="n">h</span> <span class="o">+</span> <span class="n">v</span><span class="o">)</span> <span class="o">*</span> <span class="n">rhalf</span></code></pre></div>

<pre><code>scala&gt; emit
res0: Q[Polarization] = 0.7071068|H&gt; + 0.7071068|V&gt;
</code></pre>

<p>This is</p>

<script type="math/tex; mode=display">
%<![CDATA[
\frac{1}{\sqrt 2}\ket{H} + \frac{1}{\sqrt 2}\ket{V}
%]]>
</script>

<p>meaning the photon is in a superposition of horizontal and vertical polarization.</p>

<p>Next, we pass it through a <a href="https://en.wikipedia.org/wiki/Beta_barium_borate">beta barium borate</a> (BBO) crystal, which
spontaneously turns the photon into an entangled pair of photons with orthogonal polarizations.</p>

<p>This is essentially the operation</p>

<script type="math/tex; mode=display">
%<![CDATA[
\ket{H} \rightarrow \ket{H,V}\\
\ket{V} \rightarrow \ket{V,H}
%]]>
</script>

<p>which can also be expressed as</p>

<script type="math/tex; mode=display">
%<![CDATA[
\ket{H,V}\bra{H} + \ket{V,H}\bra{V}
%]]>
</script>

<p>Or in code,</p>

<div class="highlight"><pre><code class="scala"><span class="k">val</span> <span class="nc">BBO</span> <span class="k">=</span> <span class="o">(</span><span class="n">h</span><span class="o">⊗</span><span class="n">v</span> <span class="o">&gt;&lt;</span> <span class="n">h</span><span class="o">)</span> <span class="o">+</span> <span class="o">(</span><span class="n">v</span><span class="o">⊗</span><span class="n">h</span> <span class="o">&gt;&lt;</span> <span class="n">v</span><span class="o">)</span></code></pre></div>

<p><code>&gt;&lt;</code> computes the outer product, and ⊗ is the tensor product (which you can also type as <code>*</code>, but for
the purposes of this article I thought it would be good to make a visual distinction between the tensor product and
scalar multiplication).</p>

<p>To see how this expression works, consider what happens when we apply it to <script type="math/tex">\ket{H}</script>:</p>

<script type="math/tex; mode=display">
%<![CDATA[
\ket{H,V}\braket{H}{H} + \ket{V,H}\braket{V}{H}
%]]>
</script>

<p>Since <script type="math/tex">H</script> and <script type="math/tex">V</script> are orthogonal basis vectors, their inner product, <script type="math/tex">\braket{V}{H}</script>, is
<script type="math/tex">0</script>, while the inner product of a basis vector with itself is <script type="math/tex">1</script>. So the expression evaluates to
<script type="math/tex">\ket{H,V}</script>.</p>

<p>Trying it out:</p>

<pre><code>scala&gt; h &gt;&gt;= BBO
res1: Q[T[Polarization, Polarization]] = |H,V&gt;

scala&gt; v &gt;&gt;= BBO
res2: Q[T[Polarization, Polarization]] = |V,H&gt;
</code></pre>

<p>So passing our emitted photon through the BBO crystal gives us</p>

<pre><code>scala&gt; emit &gt;&gt;= BBO
res3: Q[T[Polarization, Polarization]] = 0.7071068|H,V&gt; + 0.7071068|V,H&gt;
</code></pre>

<p>These photons are entangled: if we measure the polarization of one photon, we will get a random result, either <script type="math/tex">H</script>
or <script type="math/tex">V</script>. But then the <em>other</em> photon is guaranteed to have the opposite polarization.</p>

<p>Now we let the second photon pass through one of the two slits.</p>

<div class="highlight"><pre><code class="scala"><span class="k">val</span> <span class="n">ab</span><span class="k">:</span> <span class="kt">Q</span><span class="o">[</span><span class="kt">Slit</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">)</span> <span class="o">*</span> <span class="n">rhalf</span>
<span class="k">def</span> <span class="n">slit</span><span class="o">[</span><span class="kt">S</span> <span class="k">&lt;:</span> <span class="kt">Basis</span><span class="o">](</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span><span class="k">:</span> <span class="kt">Q</span><span class="o">[</span><span class="kt">T</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">Slit</span><span class="o">]]</span> <span class="k">=</span> <span class="n">pure</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="o">⊗</span> <span class="n">ab</span></code></pre></div>

<p>This will add a superposition of going through slits <script type="math/tex">A</script> and <script type="math/tex">B</script> to the quantum state. We’ll apply it
to the second photon using <code>lift2</code>:</p>

<pre><code>scala&gt; emit &gt;&gt;= BBO &gt;&gt;= lift2(slit)
res4: Q[T[Polarization, T[Polarization, Slit]]] = 0.5|H,V,A&gt; + 0.5|H,V,B&gt; + 0.5|V,H,A&gt; + 0.5|V,H,B&gt;
</code></pre>

<p>OK, the last thing to do is to let the second photon travel to the detector array. The quantum state will evolve over
time as the photon travels from the emitter to the detectors. This evolution happens in two ways.</p>

<p>The first is that the phase rotates with a frequency proportional to the energy of the system (which is just
proportional to the frequency of the photon). Since the units in our geometry are somewhat arbitrary,
I’m just going to say that the phase rotates one radian for each unit of distance traveled.</p>

<p>The second thing that happens is that the amplitude decreases in proportion to the square of the distance traveled.</p>

<p>We can model this as a quantum transformation as follows:</p>

<div class="highlight"><pre><code class="scala"><span class="k">def</span> <span class="n">evolve</span><span class="o">(</span><span class="n">slit</span><span class="k">:</span> <span class="kt">Slit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Q</span><span class="o">[</span><span class="kt">Detector</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">distanceBetweenSlits</span> <span class="k">=</span> <span class="mf">25.0</span>
  <span class="k">val</span> <span class="n">distanceToScreen</span> <span class="k">=</span> <span class="mf">100.0</span>
  <span class="k">val</span> <span class="n">distanceBetweenDetectors</span> <span class="k">=</span> <span class="mf">5.0</span>
  <span class="k">val</span> <span class="n">numDetectors</span> <span class="k">=</span> <span class="mi">32</span>

  <span class="k">val</span> <span class="n">slitHeight</span> <span class="k">=</span> <span class="n">slit</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">A</span> <span class="k">=&gt;</span> <span class="n">distanceBetweenSlits</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">case</span> <span class="n">B</span> <span class="k">=&gt;</span> <span class="o">-</span><span class="n">distanceBetweenSlits</span> <span class="o">/</span> <span class="mi">2</span>
  <span class="o">}</span>

  <span class="k">val</span> <span class="n">detectors</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Q</span><span class="o">[</span><span class="kt">Detector</span><span class="o">]]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">(</span><span class="n">detector</span> <span class="k">&lt;-</span> <span class="o">-</span><span class="n">numDetectors</span> <span class="n">to</span> <span class="n">numDetectors</span><span class="o">)</span> <span class="k">yield</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">height</span> <span class="k">=</span> <span class="n">detector</span> <span class="o">*</span> <span class="n">distanceBetweenDetectors</span> <span class="o">-</span> <span class="n">slitHeight</span>
    <span class="k">val</span> <span class="n">r2</span> <span class="k">=</span> <span class="n">height</span><span class="o">*</span><span class="n">height</span> <span class="o">+</span> <span class="n">distanceToScreen</span><span class="o">*</span><span class="n">distanceToScreen</span>
    <span class="k">val</span> <span class="n">distance</span> <span class="k">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="o">(</span><span class="n">r2</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">amplitude</span> <span class="k">=</span> <span class="o">(</span><span class="n">e</span> <span class="o">^</span> <span class="o">(</span><span class="n">distance</span> <span class="o">*</span> <span class="n">i</span><span class="o">))</span> <span class="o">/</span> <span class="n">r2</span>
    <span class="n">pure</span><span class="o">(</span><span class="nc">Detector</span><span class="o">(</span><span class="n">detector</span><span class="o">))</span> <span class="o">*</span> <span class="n">amplitude</span>
  <span class="o">}</span>

  <span class="n">detectors</span><span class="o">.</span><span class="n">reduce</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
<span class="o">}</span></code></pre></div>

<p>This simply models the geometry of the setup using distances that I tuned to best show the effect we’re about to see.</p>

<p>Now let’s produce our final quantum state. We’ll let the <code>Detector</code> state replace the <code>Slit</code> part of the state,
using two applications of <code>lift2</code> to apply it to the rightmost part of our nested tensor product:</p>

<pre><code>scala&gt; val stage1 = emit &gt;&gt;= BBO &gt;&gt;= lift2(slit) &gt;&gt;= lift2(lift2(evolve))
stage1: Q[T[Polarization, T[Polarization, Detector]]] = 0.1368746 + 0.0516075i|H,V,-1&gt; + 0.0877065 + -0.0664507i|H,V,-10&gt; + -0.0020936 + 0.1345861i|H,V,-11&gt; + -0.0871585 + -0.1012174i|H,V,-12&gt; + 0.10845 + 0.0320193i|H,V,-13&gt; + ...
</code></pre>

<p>OK, that’s quite a state. Let’s see what we can make of it by performing a measurement and seeing which detector the
photon arrives at:</p>

<pre><code>scala&gt; stage1.measure(_._2._2).outcome
res5: Detector = 5
</code></pre>

<p>Repeating this 10,000 times and recording the results in a histogram, we get:</p>

<pre><code>scala&gt; stage1.plotMeasurements(10000, _._2._2)
-32
-31
-30 #
-29 ##
-28 ###
-27 ####
-26 ######
-25 ######
-24 #######
-23 #########
-22 ########
-21 #########
-20 #########
-19 #######
-18 ###
-17
-16
-15 ###
-14 ##########
-13 ####################
-12 ##############################
-11 ############################
-10 ################
 -9 #####
 -8
 -7 ###########
 -6 ##################################
 -5 ########################################
 -4 ##########################
 -3 ##
 -2 #######
 -1 #################################
  0 ##################################################
  1 ################################
  2 ####
  3 ###
  4 #############################
  5 ###############################################
  6 ##################################
  7 ##############
  8
  9 #####
 10 #################
 11 ############################
 12 ###########################
 13 ####################
 14 #########
 15 ##
 16
 17 #
 18 ###
 19 #######
 20 #########
 21 ###########
 22 #########
 23 #########
 24 ########
 25 ########
 26 #####
 27 ####
 28 ###
 29 ##
 30 ##
 31 #
 32
</code></pre>

<p>Nice! That looks like an interference pattern to me. Stage 1: complete.</p>

<h3 id="stage-2-which-way-did-it-go">Stage 2: Which way did it go?</h3>

<p>We will now introduce filters at each of the slits that alter the polarization of the photons that pass through
them from a linear polarization to a circular polarization, as described above. This is achieved through an optical
device called a <a href="https://en.wikipedia.org/wiki/Polarizers#Circular_polarizers">quarter-wave plate</a> (QWP).</p>

<p>At slit <script type="math/tex">A</script> we will put a QWP that performs the following transformation:</p>

<script type="math/tex; mode=display">
%<![CDATA[
\ket{H} \rightarrow \ket{R} \\
\ket{V} \rightarrow \ket{L}
%]]>
</script>

<p>And at slit <script type="math/tex">B</script> we will put a QWP that does the opposite:</p>

<script type="math/tex; mode=display">
%<![CDATA[
\ket{H} \rightarrow \ket{L} \\
\ket{V} \rightarrow \ket{R}
%]]>
</script>

<p>The labels <script type="math/tex">R</script> and <script type="math/tex">L</script> represent clockwise and counter-clockwise circular polarizations, defined in terms
of <script type="math/tex">H</script> and <script type="math/tex">V</script> as follows:</p>

<script type="math/tex; mode=display">
%<![CDATA[
\ket{R} = \frac{\ket{H} + i\ket{V}}{\sqrt 2}\\
\ket{L} = \frac{\ket{H} - i\ket{V}}{\sqrt 2}\\
%]]>
</script>

<p>Let’s code this up:</p>

<div class="highlight"><pre><code class="scala"><span class="k">val</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Q</span><span class="o">[</span><span class="kt">Polarization</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="n">h</span> <span class="o">+</span> <span class="n">v</span><span class="o">*</span><span class="n">i</span><span class="o">)</span> <span class="o">*</span> <span class="n">rhalf</span>
<span class="k">val</span> <span class="n">left</span><span class="k">:</span> <span class="kt">Q</span><span class="o">[</span><span class="kt">Polarization</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="n">h</span> <span class="o">-</span> <span class="n">v</span><span class="o">*</span><span class="n">i</span><span class="o">)</span> <span class="o">*</span> <span class="n">rhalf</span>

<span class="k">val</span> <span class="nc">QWP</span> <span class="k">=</span> <span class="o">(</span><span class="n">right</span><span class="o">⊗</span><span class="n">a</span> <span class="o">&gt;&lt;</span> <span class="n">h</span><span class="o">⊗</span><span class="n">a</span><span class="o">)</span> <span class="o">+</span> <span class="o">(</span><span class="n">left</span><span class="o">⊗</span><span class="n">a</span> <span class="o">&gt;&lt;</span> <span class="n">v</span><span class="o">⊗</span><span class="n">a</span><span class="o">)</span> <span class="o">+</span> <span class="o">(</span><span class="n">left</span><span class="o">⊗</span><span class="n">b</span> <span class="o">&gt;&lt;</span> <span class="n">h</span><span class="o">⊗</span><span class="n">b</span><span class="o">)</span> <span class="o">+</span> <span class="o">(</span><span class="n">right</span><span class="o">⊗</span><span class="n">b</span> <span class="o">&gt;&lt;</span> <span class="n">v</span><span class="o">⊗</span><span class="n">b</span><span class="o">)</span></code></pre></div>

<p>This quantum transformation applies to the combined state of the polarization of the second photon and which slit it
went through. You can see that the first term, <script type="math/tex">\ket{R,A}\bra{H,A}</script>, for example, “selects” horizontally
polarized photons passing through slit <script type="math/tex">A</script> and gives them polarization <script type="math/tex">R</script>. In code:</p>

<pre><code>scala&gt; (h⊗a) &gt;&gt;= QWP
res0: Q[T[Polarization, Slit]] = 0.7071068|H,A&gt; + 0.7071068i|V,A&gt;
</code></pre>

<p>Let’s apply this filter to the second photon just after it goes through the slits:</p>

<pre><code>scala&gt; val s = emit &gt;&gt;= BBO &gt;&gt;= lift2(slit) &gt;&gt;= lift2(QWP)
s: Q[T[Polarization, T[Polarization, Slit]]] = 0.3535534|H,H,A&gt; + 0.3535534|H,H,B&gt; + -0.3535534i|H,V,A&gt; + 0.3535534i|H,V,B&gt; + 0.3535534|V,H,A&gt; + 0.3535534|V,H,B&gt; + 0.3535534i|V,V,A&gt; + -0.3535534i|V,V,B&gt;
</code></pre>

<p>It’s not immediately obvious here, but given this state, if you know the polarizations of both photons, you can tell
which slit the second photon went through. It becomes clearer if you write the polarization of the second photon in the
<script type="math/tex">R-L</script> basis. The state of the system is:</p>

<script type="math/tex; mode=display">
%<![CDATA[
\frac{\ket{H,L,A} + \ket{H,R,B} + \ket{V,L,B} + \ket{V,R,A}}{2}
%]]>
</script>

<p>So if you measure the first photon’s polarization to be <script type="math/tex">V</script> and the second photon’s polarization to be <script type="math/tex">R</script>,
the second photon must have gone through slit <script type="math/tex">A</script>.</p>

<p>This can also be demonstrated by using the inner product to ask the state what the
probability of collaping into some other state is:</p>

<pre><code>scala&gt; s &lt;&gt; (h ⊗ (right ⊗ a))
res1: Complex = 0

scala&gt; s &lt;&gt; (h ⊗ (right ⊗ b))
res2: Complex = 0.5
</code></pre>

<p><code>s1 &lt;&gt; s2</code> is the inner product, <script type="math/tex">\braket{s_1}{s_2}</script>.</p>

<p>So if you measure the first photon’s polarization to be <script type="math/tex">H</script> and the second photon’s polarization to be <script type="math/tex">R</script>,
the only possibility is that the second photon went through slit <script type="math/tex">B</script>.</p>

<p>OK, moving on. Now let’s let the second photon evolve as it makes its way to the detector:</p>

<pre><code>scala&gt; val stage2 = emit &gt;&gt;= BBO &gt;&gt;= lift2(slit) &gt;&gt;= lift2(QWP) &gt;&gt;= lift2(lift2(evolve))
stage2: Q[T[Polarization, T[Polarization, Detector]]] = 0.0978235 + 0.0368836i|H,H,-1&gt; + 0.0626834 + -0.047492i|H,H,-10&gt; + -0.0014963 + 0.0961879i|H,H,-11&gt; + -0.0622917 + -0.0723395i|H,H,-12&gt; + 0.0775086 + 0.022884i|H,H,-13&gt; + ...

scala&gt; stage2.plotMeasurements(10000, _._2._2)
-32 #####
-31 ###
-30 ####
-29 ####
-28 #####
-27 ######
-26 ######
-25 ########
-24 #########
-23 #########
-22 ##########
-21 ##############
-20 #############
-19 ############
-18 ###############
-17 ##################
-16 ################
-15 ####################
-14 #######################
-13 #########################
-12 ################################
-11 ###########################
-10 #################################
 -9 ##############################
 -8 ####################################
 -7 ###################################
 -6 #######################################
 -5 ###########################################
 -4 ########################################
 -3 ##########################################
 -2 ###############################################
 -1 ##################################################
  0 #############################################
  1 #################################################
  2 #############################################
  3 ###########################################
  4 ############################################
  5 ###########################################
  6 ########################################
  7 ####################################
  8 ##################################
  9 ################################
 10 #################################
 11 ##########################
 12 ##########################
 13 ########################
 14 ###################
 15 ###################
 16 ####################
 17 ################
 18 ############
 19 ##############
 20 ###########
 21 #########
 22 ########
 23 #######
 24 ########
 25 #########
 26 #######
 27 ####
 28 ####
 29 ###
 30 #####
 31 ####
 32 ####
</code></pre>

<p>Alright, that worked too! Knowing which slit the photon with through destroys the interference pattern.</p>

<h3 id="stage-3-the-quantum-eraser">Stage 3: The Quantum Eraser</h3>

<p>Now we do something pretty devious. Without touching the second photon, we can make the interference pattern reappear.
We do this by applying a <a href="https://en.wikipedia.org/wiki/Polarizers#Linear_polarizers">diagonal polarizing filter</a> to the
<em>first</em> photon.</p>

<p>A polarizing filter allows the component of an incoming photon’s polarization that is in line with the filter’s
polarization angle to pass through. In other words, the resulting photon’s polarization is the projection of its
original polarization onto the vector representing the filter’s polarization angle.</p>

<p>This can be accomplished by applying the transformation <script type="math/tex">\ket{\psi}\bra{\psi}</script>, where <script type="math/tex">\psi</script> is the
polarization of the filter. Applying this to an incoming photon with polarization <script type="math/tex">\phi</script>, we get
<script type="math/tex">\ket{\psi}\braket{\psi}{\phi}</script>.</p>

<p>The inner product <script type="math/tex">\braket{\psi}{\phi}</script> represents the proportion of the photon’s polarization that is in line with
the filter’s polarization. So the final polarization of the photon is that proportion times <script type="math/tex">\ket{\psi}</script>.</p>

<p>In code, our diagonal polarizing filter will look like:</p>

<div class="highlight"><pre><code class="scala"><span class="k">val</span> <span class="n">diag</span> <span class="k">=</span> <span class="o">(</span><span class="n">h</span> <span class="o">+</span> <span class="n">v</span><span class="o">)</span> <span class="o">*</span> <span class="n">rhalf</span>
<span class="k">val</span> <span class="n">polarizer</span> <span class="k">=</span> <span class="o">(</span><span class="n">diag</span> <span class="o">&gt;&lt;</span> <span class="n">diag</span><span class="o">)</span></code></pre></div>

<p>Now let’s apply it to the first photon:</p>

<pre><code>scala&gt; val stage3 = emit &gt;&gt;= BBO &gt;&gt;= lift2(slit) &gt;&gt;= lift2(QWP) &gt;&gt;= lift2(lift2(evolve)) &gt;&gt;= lift1(polarizer)
stage3: Q[T[Polarization, T[Polarization, Detector]]] = 0.1368746 + 0.0516075i|H,H,-1&gt; + 0.0877065 + -0.0664507i|H,H,-10&gt; + -0.0020936 + 0.1345861i|H,H,-11&gt; + -0.0871585 + -0.1012174i|H,H,-12&gt; + 0.10845 + 0.0320193i|H,H,-13&gt; + ...

scala&gt; stage3.plotMeasurements(10000, _._2._2)
-32
-31
-30 #
-29 ##
-28 ##
-27 ###
-26 ####
-25 #######
-24 #########
-23 ########
-22 ##########
-21 #########
-20 #########
-19 ######
-18 ####
-17
-16
-15 ##
-14 #########
-13 ##################
-12 ##########################
-11 #############################
-10 ####################
 -9 #####
 -8
 -7 ############
 -6 ###################################
 -5 ##########################################
 -4 ##########################
 -3 ###
 -2 #####
 -1 ###################################
  0 ##################################################
  1 ##################################
  2 ####
  3 ###
  4 ########################
  5 #############################################
  6 ##################################
  7 #############
  8
  9 ####
 10 ##################
 11 ##########################
 12 ###########################
 13 ####################
 14 ##########
 15 ###
 16
 17 #
 18 ####
 19 ######
 20 #########
 21 ########
 22 #########
 23 ########
 24 #########
 25 ######
 26 #####
 27 ####
 28 ###
 29 ##
 30 #
 31 #
 32
</code></pre>

<p>Amazing! We got our interference pattern back.</p>

<p>Let’s back up and look at the state of the system with the polarizing filter in place but before the second photon gets
to the detector:</p>

<pre><code>scala&gt; emit &gt;&gt;= BBO &gt;&gt;= lift2(slit) &gt;&gt;= lift2(QWP) &gt;&gt;= lift1(polarizer)
res0: Q[T[Polarization, T[Polarization, Slit]]] = 0.5|H,H,A&gt; + 0.5|H,H,B&gt; + 0.5|V,H,A&gt; + 0.5|V,H,B&gt;
</code></pre>

<p>So now the second photon always has a horizontal polarization, so there’s no way to tell which slit it went through.</p>

<h3 id="the-kicker">The kicker</h3>

<p>The kicker is that nothing in this setup makes reference to how far away the diagonal polarizing filter is from the rest
of the experiment apparatus. You can put it miles or light-years away, and interference pattern will still return—even
though, paradoxically, the first photon doesn’t encounter the filter until <em>after</em> the second photon reaches a detector!</p>

<p>If you want to play around with this yourself, clone
<a href="https://github.com/jliszka/quantum-probability-monad">this github project</a>
and try out the
<a href="https://github.com/jliszka/quantum-probability-monad/blob/master/src/main/scala/org/jliszka/quantum/Examples.scala#L171">quantum eraser example</a>.</p>

    </div>

    

  


  <div style="float: right; margin-top: 5px">
  <a href="https://twitter.com/share" class="twitter-share-button" data-url="http://jliszka.github.io/drafts/a-numerical-simulation-of-the-quantum-eraser.html" data-text="The Quantum Eraser" data-via="jliszka">Tweet</a>
  <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
</div>




  
    <ul class="tag_box inline">
      <li><i class="icon-tags"></i></li>
      
      


  
     
    	<li><a href="/tags.html#probability-ref">probability <span>9</span></a></li>
     
    	<li><a href="/tags.html#quantum computing-ref">quantum computing <span>1</span></a></li>
    
  



    </ul>
    
    <div style="clear: both"></div>

    <hr>
    <div class="navigation">
    
    
      <div style="clear: both"></div>
    </div>
    <hr>
    


  <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'jliszka'; // required: replace example with your forum shortname
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>




  </div>

  <div class="span2 sidebar">
    <a href="/"><div id="photo"></div></a>
    <div id="bio">
      <b>Jason Liszka</b><br/>
      <i>Software engineer at Foursquare, CMU alum, Scala fan, new father</i>
    </div>
    <h4>Popular posts</h4>
    <ul>
      <li><a href="/2013/10/01/how-traffic-actually-works.html">How traffic actually works</a></li>
      <li><a href="/2013/08/12/a-frequentist-approach-to-probability.html">A frequentist approach to probability</a></li>
      <li><a href="/2013/10/24/exact-numeric-nth-derivatives.html">Exact numeric nth derivatives</a></li>
      <li><a href="/2013/10/31/infinite-lazy-polynomials.html">Infinite lazy polynomials</a></li>
    </ul>

    <h4>Recent posts</h4>
    <ul>
      
        <li><a href="/2014/07/12/is-the-nba-draft-rigged.html">Is the NBA draft rigged?</a></li>
      
        <li><a href="/2014/06/03/programming-with-futures.html">Programming with futures: patterns and anti-patterns</a></li>
      
        <li><a href="/2014/01/30/good-tech-lead-bad-tech-lead.html">Good Tech Lead, Bad Tech Lead</a></li>
      
        <li><a href="/2013/12/18/bayesian-networks-and-causality.html">Bayesian networks and causality</a></li>
      
        <li><a href="/2013/11/22/unlikely-things-happen-all-the-time.html">Unlikely things happen all the time</a></li>
      
    </ul>

    <a href="https://twitter.com/jliszka" class="twitter-follow-button" data-show-count="false" data-size="large" data-show-screen-name="false">Follow @jliszka</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  </div>
</div>


      </div>
      <hr>
      <footer>
        <p>&copy; 2014 Jason Liszka
          with help from <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
          and <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a>
        </p>
      </footer>

    </div>

    


  <script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-42567355-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>



  </body>
</html>

